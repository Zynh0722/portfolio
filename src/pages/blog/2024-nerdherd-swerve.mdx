---
layout: "@layouts/BlogPost.astro"
title: 2024 NerdHerd Swerve Overview
description: A brief overview of the swerve code that FRC 4043 NerdHerd
  used for swerve through the 2024 season
categories: [frc, robotics, swerve]
author: Zynh Ludwig
draft: true
---

## TODO

- Figure out impact of wpilib 2025

## Preface

[YAGSL]: https://docs.yagsl.com
[CTRE's swerve framework]: https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/mechanisms/swerve/swerve-overview.html
[heading correction]: https://docs.yagsl.com/overview/our-features/heading-correction
[cosine compensation]: https://docs.yagsl.com/overview/our-features/cosine-compensation
[WPILib utils]: https://docs.wpilib.org/en/stable

The current NerdHerd swerve code's core functionality is all put together
by hand, using [WPILib utils] whenever possible to offload work. As such it also
doesn't do anything fancy that you might get with using [CTRE's swerve
framework] or [YAGSL], such as [heading correction] or [cosine compensation].
It also doesn't do some simple things, like a lock pose. This doesn't mean
those things are impossible, the code is simple enough
that any of those features could be added.

This code largely acts as a minimum barrier to entry in to swerve for teams
who are interested in implementing things largely for themselves. If you just
want something that works good with minimal effort, go use one of the previous
linked frameworks. They will likely be easier to setup, and give you a better
end result.

Also we program in Java. My apologies.

## What problem are we trying to solve?

[team 1640's definition]: https://team1640.com/wiki/index.php/Swerve_Central
[DifferentialDrive]: https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj/drive/DifferentialDrive.html
[arcadeDrive]: https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj/drive/DifferentialDrive.html#arcadeDrive(double,double)
[tankDrive]: https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj/drive/DifferentialDrive.html#tankDrive(double,double)
[differential drivebase]: https://www.andymark.com/products/am14u5-6-wheel-drop-center-robot-drive-base-first-kit-of-parts-chassis

Outside of FRC the defintion of swerve drive is a bit more broad, but for the
purposes of FRC, I quite like [team 1640's definition], where a swerve drive is
any drive train where **all drive wheels are independently driven and steered**.

And to everyone's surpise, our team wanted to control our robot with some kind
of joystick? and they expect it to move?

If we were making a skid steer platform, we could just use [DifferentialDrive]
and be done with it. Directly pipe our controller inputs into the diffdrive's
[tankDrive] or [arcadeDrive] methods, and we'd have a driving robot.

Unfortunately with a swerve drive we can't simply map out inputs to our outputs,
as in all but the simplest case, our motor directions and speeds have no
correlation to our joystick inputs. This is unlike a [differential drivebase]
where moving the stick forward directly translates to rotating the wheels
forward.

We'll pin the joystick thing until later and for now we will simply work on
getting the robot to move without a joystick.

### The components of swerve drive control

As usual with a difficult task, we should start by breaking one hard problem,
into two smaller and slightly different problems. While WPILib doesn't provide a
class that will make our new swerve robot drive out of the box, it does provide
implementations for all of the difficult to solve problems that prevent you from
driving with a swerve drive base.

#### Inverse Kinematics

The first and more difficult of the two problems is figuring out where we even
want the swerve modules to point. We want to be able to define the linear and
angular velocity we want our robot to move, and get the individual velocities
of our swerve modules necessary to achieve that.

> I am sorry in advance to anyone seeking clarity in terminology, I will be
> switching between speed and velocity in this article, when most of the time I
> mean velocity.

If we were getting the resulting robot speed from individual module speeds, that
math would be referred to as Kinematics, however we want to do the opposite.
Getting the component module speeds to reach a target robot speed would be
Inverse Kinematics!

Now that I've introduced the terminology, I'll now break the news that I won't
be going over the inverse kinematics math. The general case is very solveable
with a little linear algebra experience, and the simpler case that you more
likely have on your robot is solveable with trig, albeit the implementation I
think will be slower. I highly encourage you to explore solving this math
yourself, as well as comparing your math to other people's implementations online.

However I am interested in getting a robot running using just WPILib and elbow
grease, and thankfully WPILib has our backs for this problem.

If our robot had no need to turn, we could simply point all motors in the
direction of the target heading

##### SwerveDriveKinematics

[examples for most of it's features]: https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/swerve-drive-kinematics.html
[seen here]: https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/swerve-drive-kinematics.html#converting-chassis-speeds-to-module-states

WPILib provides us with the `SwerveDriveKinematics` class, and gives us
[examples for most of it's features]. All you need to do is give it the
locations for your swerve modules, and it will return an object that
can turn a `ChassisSpeeds` object into an array of `SwerveModuleState`s,
which can be [seen here].

This lets us define the speed the robot should be moving, and get the
speed we want each individual module to be moving.

The code we are currently using utilizes WPILibs module angle optimization, but
WPILib also provides a tool for cosine compensation.

I'll go over our 2024 code later on, but I'll briefly describe the two buzzwords
I just used.

###### Module Angle Optimization

[WPILib docs example]: https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/swerve-drive-kinematics.html#converting-chassis-speeds-to-module-states

One thing you may notice when setting up a swerve controller that controls your
swerve modules, is that when you're driving forward, and then start driving back
wards, the modules need to turn 180 degrees before your robot can start driving
in the other direction.

The trick is that all we really need to do in that scenario is start driving tha
t wheel in the other direction without changing the heading at all. Additionally
if you are pointing at 45 degrees, and you need to be pointing at 180 degrees,
it's easier to point at 0 degrees and reverse the module's speed.

Here's the [WPILib docs example].

###### Cosine Compensation

[WPILib docs explain in a tiny bit more depth]: https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/swerve-drive-kinematics.html#cosine-compensation

The [WPILib docs explain in a tiny bit more depth], but when controlling a
swerve drive, the current heading of the swerve module won't instantly match
the target head ing, which means briefly whilst turning toward it's target, the
module will be moving in the wrong direction.

Cosine compensation simply reduces the speed of the module while it isn't
pointing in the desired direction.

Our code doesn't currently use this, but in theory it could for the 2025 season.

#### Module Control

Once we know what speed and direction the modules need to go, we need to
actually control the motors

##### PID Control

## Our Code
